schema {
  query: AppQueries
  mutation: AppMutations
}

type Address {
  street: String!
  city: String!
  state: String!
  country: String!
  zipCode: String!
}

type AppConfig {
  configFilePath: String!
  applicationName: String
  configName: String
  description: String
  address: Address
  isActive: Boolean!
  unitSystem: String
  timeZone: String
  downloadServerUrl: String
  baseFolderName: String
  configFolderName: String
  configFolderPath: String
  configFileName: String
  pluginFolderName: String
  pluginFolderPath: String
  logFolderName: String
  logFolderPath: String
  deleteXAmountAfterLimit: Int
  saveXLimit: Int
}

"Main entrypoint for all mutations."
type AppMutations {
  login(input: LoginInput!): IdentityPayload!
  registration(input: RegistrationInput!): IdentityPayload!
  initializeApp(input: AppConfigInitInput!): InitPayload!
  createGroup(input: CreateGroupInput!): GroupPayload!
  updateGroup(input: UpdateGroupInput!): GroupPayload!
  createDevice(input: CreateDeviceInput!): DevicePayload!
  updateDevice(input: UpdateDeviceInput!): DevicePayload!
  updateUser(input: UpdateUserInput!): UserPayload!
}

"Main entrypoint for all queries."
type AppQueries {
  groups(where: GroupFilterInput order: [GroupSortInput!]): [Group!]!
  groupsCount: Int!
  devices(where: DeviceFilterInput order: [DeviceSortInput!]): [Device!]!
  devicesCount: Int!
  me: IdentityPayload!
  appConfig: AppConfig! @authorize(apply: BEFORE_RESOLVER)
  usersExist: Boolean!
  applicationIsActive: Boolean!
  scanNetworkDevices(where: NetworkDeviceFilterInput order: [NetworkDeviceSortInput!]): [NetworkDevice!]!
  setLightState(input: DeviceLightStateInput!): DeviceStatePayload!
}

type BaseEntity {
  setName(name: String!): BaseEntity!
  setDescription(description: String!): BaseEntity!
  id: String!
  name: String!
  description: String
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: String!
  lastModifiedBy: String!
}

type Company {
  name: String!
  shortName: String!
}

type Device {
  setName(name: String!): BaseEntity!
  setDescription(description: String!): BaseEntity!
  ip: IpAddress!
  company: Company!
  primaryConnection: ConnectionTypes!
  secondaryConnection: ConnectionTypes!
  pluginName: String!
  pluginTypes: PluginTypes!
  groups: [Group!]!
  id: String!
  name: String!
  description: String
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: String!
  lastModifiedBy: String!
  status: StatusResponseType
}

type DevicePayload {
  device: Device
  errors: [UserError!]
  message: String
}

type DeviceStatePayload {
  lightResponseType: LightResponseType
  errors: [UserError!]
  message: String
}

type Group {
  setName(name: String!): BaseEntity!
  setDescription(description: String!): BaseEntity!
  devices: [Device!]!
  id: String!
  name: String!
  description: String
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: String!
  lastModifiedBy: String!
}

type GroupPayload {
  group: Group
  errors: [UserError!]
  message: String
}

type IdentityPayload {
  token: String
  user: User
  errors: [UserError!]
  message: String
}

type InitPayload {
  appConfig: AppConfig
  errors: [UserError!]
  message: String
}

type IpAddress {
  ipv4: String!
}

type LightResponseType {
  ison: Boolean!
  mode: String
  red: Int!
  green: Int!
  blue: Int!
  white: Int!
}

type NetworkDevice {
  name: String
  description: String
  ipv4: String
  ipv6: String
  hostname: String
  macAddress: String
}

type PersonName {
  firstName: String!
  middleName: String!
  lastName: String!
}

type StatusResponseType {
  lights: [LightResponseType]
}

type User {
  createdAt: DateTime!
  lastModifiedAt: DateTime!
  createdBy: String!
  lastModifiedBy: String!
  isFirstLogin: Boolean!
  personInfo: String!
  personName: PersonName!
  id: String
  userName: String
  normalizedUserName: String
  email: String
  normalizedEmail: String
  emailConfirmed: Boolean!
  passwordHash: String
  securityStamp: String
  concurrencyStamp: String
  phoneNumber: String
  phoneNumberConfirmed: Boolean!
  twoFactorEnabled: Boolean!
  lockoutEnd: DateTime
  lockoutEnabled: Boolean!
  accessFailedCount: Int!
}

type UserError {
  message: String!
  code: AppErrorCodes!
}

type UserPayload {
  user: User!
  errors: [UserError!]
  message: String
}

input AppConfigInitInput {
  name: String
  description: String
  autoDetectAddress: Boolean!
}

input CompanyFilterInput {
  and: [CompanyFilterInput!]
  or: [CompanyFilterInput!]
  name: StringOperationFilterInput
  shortName: StringOperationFilterInput
}

input CompanySortInput {
  name: SortEnumType
  shortName: SortEnumType
}

input ComparableDateTimeOffsetOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime!]
  nin: [DateTime!]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input ConnectionTypesOperationFilterInput {
  eq: ConnectionTypes
  neq: ConnectionTypes
  in: [ConnectionTypes!]
  nin: [ConnectionTypes!]
}

input CreateDeviceInput {
  name: String!
  description: String
  ipv4: String!
  companyName: String!
  pluginName: String!
  groupName: String
  pluginTypes: PluginTypes!
  primaryConnection: ConnectionTypes!
  secondaryConnection: ConnectionTypes!
}

input CreateGroupInput {
  name: String!
  description: String
}

input DeviceFilterInput {
  and: [DeviceFilterInput!]
  or: [DeviceFilterInput!]
  ip: IpAddressFilterInput
  company: CompanyFilterInput
  primaryConnection: ConnectionTypesOperationFilterInput
  secondaryConnection: ConnectionTypesOperationFilterInput
  pluginName: StringOperationFilterInput
  pluginTypes: PluginTypesOperationFilterInput
  groups: ListFilterInputTypeOfGroupFilterInput
  id: StringOperationFilterInput
  name: StringOperationFilterInput
  description: StringOperationFilterInput
  createdAt: ComparableDateTimeOffsetOperationFilterInput
  lastModifiedAt: ComparableDateTimeOffsetOperationFilterInput
  createdBy: StringOperationFilterInput
  lastModifiedBy: StringOperationFilterInput
}

input DeviceLightStateInput {
  deviceId: String!
  setLight: Boolean!
}

input DeviceSortInput {
  ip: IpAddressSortInput
  company: CompanySortInput
  primaryConnection: SortEnumType
  secondaryConnection: SortEnumType
  pluginName: SortEnumType
  pluginTypes: SortEnumType
  id: SortEnumType
  name: SortEnumType
  description: SortEnumType
  createdAt: SortEnumType
  lastModifiedAt: SortEnumType
  createdBy: SortEnumType
  lastModifiedBy: SortEnumType
}

input GroupFilterInput {
  and: [GroupFilterInput!]
  or: [GroupFilterInput!]
  devices: ListFilterInputTypeOfDeviceFilterInput
  id: StringOperationFilterInput
  name: StringOperationFilterInput
  description: StringOperationFilterInput
  createdAt: ComparableDateTimeOffsetOperationFilterInput
  lastModifiedAt: ComparableDateTimeOffsetOperationFilterInput
  createdBy: StringOperationFilterInput
  lastModifiedBy: StringOperationFilterInput
}

input GroupSortInput {
  id: SortEnumType
  name: SortEnumType
  description: SortEnumType
  createdAt: SortEnumType
  lastModifiedAt: SortEnumType
  createdBy: SortEnumType
  lastModifiedBy: SortEnumType
}

input IpAddressFilterInput {
  and: [IpAddressFilterInput!]
  or: [IpAddressFilterInput!]
  ipv4: StringOperationFilterInput
}

input IpAddressSortInput {
  ipv4: SortEnumType
}

input ListFilterInputTypeOfDeviceFilterInput {
  all: DeviceFilterInput
  none: DeviceFilterInput
  some: DeviceFilterInput
  any: Boolean
}

input ListFilterInputTypeOfGroupFilterInput {
  all: GroupFilterInput
  none: GroupFilterInput
  some: GroupFilterInput
  any: Boolean
}

input LoginInput {
  userName: String!
  password: String!
}

input NetworkDeviceFilterInput {
  and: [NetworkDeviceFilterInput!]
  or: [NetworkDeviceFilterInput!]
  name: StringOperationFilterInput
  description: StringOperationFilterInput
  ipv4: StringOperationFilterInput
  ipv6: StringOperationFilterInput
  hostname: StringOperationFilterInput
  macAddress: StringOperationFilterInput
}

input NetworkDeviceSortInput {
  name: SortEnumType
  description: SortEnumType
  ipv4: SortEnumType
  ipv6: SortEnumType
  hostname: SortEnumType
  macAddress: SortEnumType
}

input PluginTypesOperationFilterInput {
  eq: PluginTypes
  neq: PluginTypes
  in: [PluginTypes!]
  nin: [PluginTypes!]
}

input RegistrationInput {
  userName: String!
  password: String!
  role: String!
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

input UpdateDeviceInput {
  id: String!
  name: String
  description: String
  ipv4: String
  groupName: String
  primaryConnection: ConnectionTypes
  secondaryConnection: ConnectionTypes
}

input UpdateGroupInput {
  id: String!
  name: String
  description: String
}

input UpdateUserInput {
  userId: String!
  userName: String
  personInfo: String
  firstName: String
  middleName: String
  lastName: String
  email: String
  phoneNumber: String
  newRole: String
}

enum AppErrorCodes {
  SERVER_ERROR
  NOT_FOUND
  NOT_CREATED
  NOT_UPDATED
  EXISTS
  NO_HOME
  NOT_SET
  NOT_AUTHORIZED
  IS_EMPTY
  IS_SUB_GROUP
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
}

enum ConnectionTypes {
  NONE
  HTTP
  MQTT
}

enum PluginTypes {
  NONE
  BASE
  MOCK
  DOOR
  LIGHT
  HT
  SENSOR
  RGB
}

enum SortEnumType {
  ASC
  DESC
}

directive @authorize("The name of the authorization policy that determines access to the annotated resource." policy: String "Roles that are allowed to access the annotated resource." roles: [String!] "Defines when when the resolver shall be executed.By default the resolver is executed after the policy has determined that the current user is allowed to access the field." apply: ApplyPolicy! = BEFORE_RESOLVER) repeatable on SCHEMA | OBJECT | FIELD_DEFINITION

"The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`."
directive @defer("If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to." label: String "Deferred when true." if: Boolean) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"The @deprecated directive is used within the type system definition language to indicate deprecated portions of a GraphQL service’s schema,such as deprecated fields on a type or deprecated enum values."
directive @deprecated("Deprecations include a reason for why it is deprecated, which is formatted using Markdown syntax (as specified by CommonMark)." reason: String = "No longer supported") on FIELD_DEFINITION | ENUM_VALUE

"Directs the executor to include this field or fragment only when the `if` argument is true."
directive @include("Included when true." if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Directs the executor to skip this field or fragment when the `if` argument is true."
directive @skip("Skipped when true." if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

"The `@stream` directive may be provided for a field of `List` type so that the backend can leverage technology such as asynchronous iterators to provide a partial list in the initial response, and additional list items in subsequent responses. `@include` and `@skip` take precedence over `@stream`."
directive @stream("If this argument label has a value other than null, it will be passed on to the result of this stream directive. This label is intended to give client applications a way to identify to which fragment a streamed result belongs to." label: String "The initial elements that shall be send down to the consumer." initialCount: Int! "Streamed when true." if: Boolean!) on FIELD

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")