# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: AppQueries
    mutation: AppMutations
}

type Address {
    city: String!
    country: String!
    state: String!
    street: String!
    zipCode: String!
}

type AppConfig {
    address: Address
    applicationName: String
    baseFolderName: String
    configFileName: String
    configFilePath: String!
    configFolderName: String
    configFolderPath: String
    configName: String
    deleteXAmountAfterLimit: Int
    description: String
    downloadServerUrl: String
    isActive: Boolean!
    logFolderName: String
    logFolderPath: String
    pluginFolderName: String
    pluginFolderPath: String
    saveXLimit: Int
    timeZone: String
    unitSystem: String
}

"All mutations for the identity services."
type AppMutations {
    createDevice(input: CreateDeviceInput!): DevicePayload!
    createGroup(input: CreateGroupInput!): GroupPayload!
    initializeApp(input: AppConfigInitInput!): InitPayload!
    login(input: LoginInput!): IdentityPayload!
    registration(input: RegistrationInput!): IdentityPayload!
    updateDevice(input: UpdateDeviceInput!): DevicePayload!
    updateGroup(input: UpdateGroupInput!): GroupPayload!
}

"All queries for the me services."
type AppQueries {
    appConfig: AppConfig!
    applicationIsActive: Boolean!
    devices(order: [DeviceSortInput!], where: DeviceFilterInput): [Device!]!
    groups(order: [GroupSortInput!], where: GroupFilterInput): [Group!]!
    me: User
    scanNetworkDevices(order: [NetworkDeviceSortInput!], where: NetworkDeviceFilterInput): [NetworkDevice!]!
    usersExist: Boolean!
}

type BaseEntity {
    createdAt: DateTime!
    createdBy: String!
    description: String
    id: String!
    lastModifiedAt: DateTime!
    lastModifiedBy: String!
    name: String!
    setDescription(description: String!): BaseEntity!
    setName(name: String!): BaseEntity!
}

type Company {
    name: String!
    shortName: String!
}

type Device {
    company: Company!
    createdAt: DateTime!
    createdBy: String!
    description: String
    groups: [Group!]!
    id: String!
    ip: IpAddress!
    lastModifiedAt: DateTime!
    lastModifiedBy: String!
    name: String!
    pluginName: String!
    pluginTypes: PluginTypes!
    primaryConnection: ConnectionTypes!
    secondaryConnection: ConnectionTypes!
    setConnectionTypes(primary: ConnectionTypes!, secondary: ConnectionTypes!): Device!
    setDescription(description: String!): BaseEntity!
    setIp(ip: String!): Device!
    setName(name: String!): BaseEntity!
}

type DevicePayload {
    device: Device
    errors: [UserError!]
    message: String
}

type Group {
    addDevice(newDevice: DeviceInput!): Group!
    addSubGroup: Group!
    createdAt: DateTime!
    createdBy: String!
    description: String
    devices: [Device!]!
    id: String!
    isSubGroup: Boolean!
    lastModifiedAt: DateTime!
    lastModifiedBy: String!
    name: String!
    setDescription(description: String!): BaseEntity!
    setName(name: String!): BaseEntity!
    subGroups: [Group!]!
}

type GroupPayload {
    errors: [UserError!]
    group: Group
    message: String
}

type IdentityPayload {
    errors: [UserError!]
    message: String
    token: String
    user: User
}

type InitPayload {
    appConfig: AppConfig
    errors: [UserError!]
    message: String
}

type IpAddress {
    ipv4: String!
}

type NetworkDevice {
    description: String
    hostname: String
    ipv4: String
    ipv6: String
    macAddress: String
    name: String
}

type PersonName {
    firstName: String!
    lastName: String!
    middleName: String!
}

type User {
    accessFailedCount: Int!
    concurrencyStamp: String
    createdAt: DateTime!
    createdBy: String!
    email: String
    emailConfirmed: Boolean!
    id: String
    lastModifiedAt: DateTime!
    lastModifiedBy: String!
    lockoutEnabled: Boolean!
    lockoutEnd: DateTime
    normalizedEmail: String
    normalizedUserName: String
    passwordHash: String
    personInfo: String!
    personName: PersonName!
    phoneNumber: String
    phoneNumberConfirmed: Boolean!
    securityStamp: String
    twoFactorEnabled: Boolean!
    userName: String
}

type UserError {
    code: AppErrorCodes!
    message: String!
}

enum AppErrorCodes {
    EXISTS
    IS_EMPTY
    IS_SUB_GROUP
    NOT_CREATED
    NOT_FOUND
    NOT_UPDATED
    SERVER_ERROR
}

enum ConnectionTypes {
    HTTP
    MQTT
    NONE
}

enum PluginTypes {
    BASE
    DOOR
    HT
    LIGHT
    MOCK
    NONE
    RGB
    SENSOR
}

enum SortEnumType {
    ASC
    DESC
}

input AppConfigInitInput {
    autoDetectAddress: Boolean!
    description: String!
    name: String!
}

input BooleanOperationFilterInput {
    eq: Boolean
    neq: Boolean
}

input CompanyFilterInput {
    and: [CompanyFilterInput!]
    name: StringOperationFilterInput
    or: [CompanyFilterInput!]
    shortName: StringOperationFilterInput
}

input CompanyInput {
    name: String!
    shortName: String!
}

input CompanySortInput {
    name: SortEnumType
    shortName: SortEnumType
}

input ComparableDateTimeOffsetOperationFilterInput {
    eq: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    neq: DateTime
    ngt: DateTime
    ngte: DateTime
    nin: [DateTime!]
    nlt: DateTime
    nlte: DateTime
}

input ConnectionTypesOperationFilterInput {
    eq: ConnectionTypes
    in: [ConnectionTypes!]
    neq: ConnectionTypes
    nin: [ConnectionTypes!]
}

input CreateDeviceInput {
    companyName: String!
    description: String
    groupName: String!
    ipv4: String!
    name: String!
    pluginName: String!
    pluginTypes: PluginTypes!
    primaryConnection: ConnectionTypes!
    secondaryConnection: ConnectionTypes!
}

input CreateGroupInput {
    description: String!
    isSubGroup: Boolean!
    name: String!
    parentGroupId: String
}

input DeviceFilterInput {
    and: [DeviceFilterInput!]
    company: CompanyFilterInput
    createdAt: ComparableDateTimeOffsetOperationFilterInput
    createdBy: StringOperationFilterInput
    description: StringOperationFilterInput
    groups: ListFilterInputTypeOfGroupFilterInput
    id: StringOperationFilterInput
    ip: IpAddressFilterInput
    lastModifiedAt: ComparableDateTimeOffsetOperationFilterInput
    lastModifiedBy: StringOperationFilterInput
    name: StringOperationFilterInput
    or: [DeviceFilterInput!]
    pluginName: StringOperationFilterInput
    pluginTypes: PluginTypesOperationFilterInput
    primaryConnection: ConnectionTypesOperationFilterInput
    secondaryConnection: ConnectionTypesOperationFilterInput
}

input DeviceInput {
    company: CompanyInput!
    createdAt: DateTime!
    createdBy: String!
    description: String
    groups: [GroupInput!]!
    id: String!
    ip: IpAddressInput!
    lastModifiedAt: DateTime!
    lastModifiedBy: String!
    name: String!
    pluginName: String!
    pluginTypes: PluginTypes!
    primaryConnection: ConnectionTypes!
    secondaryConnection: ConnectionTypes!
}

input DeviceSortInput {
    company: CompanySortInput
    createdAt: SortEnumType
    createdBy: SortEnumType
    description: SortEnumType
    id: SortEnumType
    ip: IpAddressSortInput
    lastModifiedAt: SortEnumType
    lastModifiedBy: SortEnumType
    name: SortEnumType
    pluginName: SortEnumType
    pluginTypes: SortEnumType
    primaryConnection: SortEnumType
    secondaryConnection: SortEnumType
}

input GroupFilterInput {
    and: [GroupFilterInput!]
    createdAt: ComparableDateTimeOffsetOperationFilterInput
    createdBy: StringOperationFilterInput
    description: StringOperationFilterInput
    devices: ListFilterInputTypeOfDeviceFilterInput
    id: StringOperationFilterInput
    isSubGroup: BooleanOperationFilterInput
    lastModifiedAt: ComparableDateTimeOffsetOperationFilterInput
    lastModifiedBy: StringOperationFilterInput
    name: StringOperationFilterInput
    or: [GroupFilterInput!]
    subGroups: ListFilterInputTypeOfGroupFilterInput
}

input GroupInput {
    createdAt: DateTime!
    createdBy: String!
    description: String
    devices: [DeviceInput!]!
    id: String!
    isSubGroup: Boolean!
    lastModifiedAt: DateTime!
    lastModifiedBy: String!
    name: String!
    subGroups: [GroupInput!]!
}

input GroupSortInput {
    createdAt: SortEnumType
    createdBy: SortEnumType
    description: SortEnumType
    id: SortEnumType
    isSubGroup: SortEnumType
    lastModifiedAt: SortEnumType
    lastModifiedBy: SortEnumType
    name: SortEnumType
}

input IpAddressFilterInput {
    and: [IpAddressFilterInput!]
    ipv4: StringOperationFilterInput
    or: [IpAddressFilterInput!]
}

input IpAddressInput {
    ipv4: String!
}

input IpAddressSortInput {
    ipv4: SortEnumType
}

input ListFilterInputTypeOfDeviceFilterInput {
    all: DeviceFilterInput
    any: Boolean
    none: DeviceFilterInput
    some: DeviceFilterInput
}

input ListFilterInputTypeOfGroupFilterInput {
    all: GroupFilterInput
    any: Boolean
    none: GroupFilterInput
    some: GroupFilterInput
}

input LoginInput {
    password: String!
    userName: String!
}

input NetworkDeviceFilterInput {
    and: [NetworkDeviceFilterInput!]
    description: StringOperationFilterInput
    hostname: StringOperationFilterInput
    ipv4: StringOperationFilterInput
    ipv6: StringOperationFilterInput
    macAddress: StringOperationFilterInput
    name: StringOperationFilterInput
    or: [NetworkDeviceFilterInput!]
}

input NetworkDeviceSortInput {
    description: SortEnumType
    hostname: SortEnumType
    ipv4: SortEnumType
    ipv6: SortEnumType
    macAddress: SortEnumType
    name: SortEnumType
}

input PluginTypesOperationFilterInput {
    eq: PluginTypes
    in: [PluginTypes!]
    neq: PluginTypes
    nin: [PluginTypes!]
}

input RegistrationInput {
    password: String!
    role: String!
    userName: String!
}

input StringOperationFilterInput {
    and: [StringOperationFilterInput!]
    contains: String
    endsWith: String
    eq: String
    in: [String]
    ncontains: String
    nendsWith: String
    neq: String
    nin: [String]
    nstartsWith: String
    or: [StringOperationFilterInput!]
    startsWith: String
}

input UpdateDeviceInput {
    description: String
    groupName: String!
    id: String!
    ipv4: String!
    name: String!
    primaryConnection: ConnectionTypes!
    secondaryConnection: ConnectionTypes!
}

input UpdateGroupInput {
    description: String!
    id: String!
    name: String
}


"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime
